# Документация к реализации алгоритма чет-нечетной сортировки для матрицы на NASM x86_64

## Структура программы

1. Секция данных (section .data)

        rows: db 3        ; Количество строк (3 строки)
        cols: db 5        ; Количество столбцов (5 элементов в строке)
        matrix:           ; Матрица 3x5 (каждый элемент - 2 байта)
            dw 12, -5, 7, 3, 0   ; Строка 0: 12, -5, 7, 3, 0
            dw 4, 9, -2, 6, 1    ; Строка 1: 4, 9, -2, 6, 1
            dw -1, 8, 15, 2, -3  ; Строка 2: -1, 8, 15, 2, -3

* rows/cols: Байтовые значения для хранения размеров матрицы

* matrix: Данные матрицы хранятся построчно, каждый элемент занимает 2 байта (директива dw)

2. Секция кода (section .text)

## Глобальная точка входа

    global _start
    _start:
        mov r8, -1       ; Инициализация счетчика строк (-1 для корректного старта)

## Алгоритм сортировки

### Основные компоненты

* Цикл обработки строк (rowloop)

+ Нечетная фаза сортировки (colloop_odd)

* Четная фаза сортировки (colloop_even)

* Механизм сравнения и обмена (cmp/swap)

### Детальное описание работы

1. Цикл по строкам матрицы

        rowloop:
            add r8b, 1           ; Инкремент номера текущей строки
            cmp r8b, [rows]      ; Проверка: все строки обработаны?
            jae _end             ; Если да - завершение программы
            mov r9b, 0           ; Сброс счетчика столбцов
            jmp colloop_odd      ; Старт нечетной фазы

* r8b: Младший байт регистра r8 (счетчик строк 0..2)

* jae _end: Переход при достижении последней строки

2. Нечетная фаза (сравнение четных индексов: 0-1, 2-3)

        colloop_odd:
            mov r14, 1                 ; Флаг нечетной фазы
            mov r12b, [cols]           ; Загрузка количества столбцов
            sub r12b, 1                ; cols-1 (максимальный индекс)
            cmp r9b, r12b              ; Проверка выхода за границы
            jae pre_colloop_even       ; Переход к четной фазе при необходимости

        ; Вычисление адреса matrix[row][col]
        movzx rax, r8b             ; Номер строки
        imul rax, [cols]           ; Умножение на количество столбцов
        imul rax, 2                ; Коррекция на размер элемента (2 байта)
        movzx rbx, r9b             ; Номер столбца
        imul rbx, 2                ; Смещение в байтах
        mov si, [matrix+rax+rbx]   ; Загрузка текущего элемента
        mov cx, [matrix+rax+rbx+2] ; Загрузка следующего элемента
        add r9b, 2                 ; Переход к следующей паре
        jmp cmp                    ; Переход к сравнению

3. Четная фаза (сравнение нечетных индексов: 1-2, 3-4)

        colloop_even:
            mov r14, 0                 ; Флаг четной фазы
            ...                        ; Аналогичная логика вычислений
            jmp cmp                    ; Переход к сравнению

4. Механизм сравнения и обмена

        cmp:
            %ifdef SORT_DESCENDING
                cmp si, cx      ; Сравнение для сортировки по убыванию
            %else
                cmp cx, si      ; Сравнение для сортировки по возрастанию
            %endif

        jg swap             ; Обмен при необходимости
        jle not_swap        ; Пропуск обмена

        swap:
            ; Обмен значений местами
            mov [matrix+rax+rbx+2], si
            mov [matrix+rax+rbx], cx
            mov r13, 1          ; Флаг изменения данных
            ...                 ; Возврат в соответствующий цикл

## Ключевые особенности

### Адресация элементов матрицы
    
    Формула: адрес = matrix + (row * cols + col) * 2
    
    Пример: matrix[1][2] = base + (1*5 + 2)*2 = base + 14 байт

### Управление фазами

    Регистр R14: 1 для нечетной фазы, 0 для четной
    
    После каждого обмена - возврат в начало фазы

### Оптимизации

    Использование 8-битных регистров (r8b, r9b)
    
    Перерасчет адресов при каждой итерации

### Условная компиляция
    
    Сборка с -dSORT_DESCENDING меняет порядок сортировки

## Пример работы алгоритма

Исходная строка: [12, -5, 7, 3, 0]

    Нечетная фаза:

        Сравнение (12 ↔ -5) → обмен → [-5, 12, 7, 3, 0]

        Сравнение (7 ↔ 3) → обмен → [-5, 12, 3, 7, 0]

    Четная фаза:

        Сравнение (12 ↔ 3) → обмен → [-5, 3, 12, 7, 0]

        Сравнение (7 ↔ 0) → обмен → [-5, 3, 12, 0, 7]

    Повторение фаз до полной сортировки

## Завершение программы

    _end:
        mov eax, 60     ; Системный вызов exit
        mov edi, 0      ; Код возврата 0
        syscall         ; Завершение программы

## Визуализация памяти

## Структура матрицы в памяти (смещения в байтах):

    Строка 0: 0x00: 12   (-5)   7    3    0
    Строка 1: 0x0A: 4    9     (-2)  6    1
    Строка 2: 0x14: -1   8     15    2    (-3)

## Особенности реализации

    Многопроходная сортировка: Алгоритм повторяет фазы до полной сортировки

    Стабильность: Сохраняет порядок равных элементов

    Сложность: O(n²) в худшем случае

    Применимость: Эффективен для небольших наборов данных
