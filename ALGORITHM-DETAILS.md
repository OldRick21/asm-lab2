# Odd-Even Sort Implementation in NASM x86_64 Assembly

Детальное пошаговое объяснение реализации алгоритма чет-нечетной сортировки для матрицы 3x5. Каждая строка кода прокомментирована.

## Полный листинг с комментариями

### Секция данных
```asm
section .data
    rows: db 3        ; [1] Байт: количество строк (3)
    cols: db 5        ; [2] Байт: количество столбцов (5)
    matrix:           ; [3] Матрица 3x5 (каждый элемент - слово, 2 байта)
        dw 12, -5, 7, 3, 0   ; [4] Строка 0
        dw 4, 9, -2, 6, 1    ; [5] Строка 1
        dw -1, 8, 15, 2, -3  ; [6] Строка 2

Секция кода
asm
Copy

section .text
global _start
_start:
    ; Инициализация счетчика строк
    mov r8, -1        ; [7] R8 = -1 (стартовое значение для rowloop)
                      ; Используем 64-битный регистр, но работаем с младшим байтом (r8b)

rowloop:
    ; Обработка строки --------------------------------------------------------
    add r8b, 1        ; [8] Инкремент счетчика строк: r8b += 1
    cmp r8b, [rows]   ; [9] Сравнение: текущая строка (r8b) vs общее количество строк
    jae _end          ; [10] Если r8b >= rows, завершить программу (jump above or equal)

    ; Подготовка к чет-нечетной сортировке внутри строки
    mov r9b, 0        ; [11] Сброс счетчика столбцов для нечетной фазы (r9b = 0)
    jmp colloop_odd   ; [12] Начать с нечетной фазы сравнения

colloop_odd:
    ; Нечетная фаза: сравнение элементов (0,1), (2,3) -------------------------
    mov r14, 1        ; [13] Флаг фазы: 1 = нечетная фаза
    mov r12b, [cols]  ; [14] Загрузка количества столбцов в r12b
    sub r12b, 1       ; [15] cols-1 (последний элемент не имеет пары)
    cmp r9b, r12b     ; [16] Проверка: достигли ли конца строки?
    jae pre_colloop_even ; [17] Если да, перейти к четной фазе

    ; Вычисление адреса matrix[row][col]
    movzx rax, r8b    ; [18] Загрузка номера строки в RAX (zero-extend)
    movsx rdi, byte [cols] ; [19] Загрузка cols в RDI (sign-extend)
    imul rax, rdi     ; [20] row * cols
    imul rax, 2       ; [21] *2 (размер элемента = 2 байта)
    movzx rbx, r9b    ; [22] Загрузка номера столбца в RBX
    imul rbx, 2       ; [23] *2 (смещение внутри строки)
    mov si, [matrix+rax+rbx] ; [24] Загрузка текущего элемента в SI (16 бит)

    ; Получение следующего элемента (col+1)
    mov cx, [matrix+rax+rbx+2] ; [25] Загрузка следующего элемента в CX
    add r9b, 2       ; [26] Переход к следующей паре: col += 2
    jmp cmp          ; [27] Переход к сравнению элементов

pre_colloop_even:
    ; Подготовка к четной фазе ------------------------------------------------
    mov r9b, 1        ; [28] Начать сравнения с индекса 1
    jmp colloop_even  ; [29] Переход к четной фазе

colloop_even:
    ; Четная фаза: сравнение элементов (1,2), (3,4) ---------------------------
    mov r14, 0        ; [30] Флаг фазы: 0 = четная фаза
    mov r12b, [cols]  ; [31] Повторная проверка границ
    sub r12b, 1
    cmp r9b, r12b
    jae rowloop       ; [32] Если обработаны все пары, вернуться к следующей строке

    ; Аналогичные вычисления адресов как в нечетной фазе
    movzx rax, r8b
    movsx rdi, byte [cols]
    imul rax, rdi
    imul rax, 2
    movzx rbx, r9b
    imul rbx, 2
    mov si, [matrix+rax+rbx]
    mov cx, [matrix+rax+rbx+2]
    add r9b, 2
    jmp cmp

cmp:
    ; Логика сравнения --------------------------------------------------------
    %ifdef SORT_DESCENDING  ; [33] Условная компиляция для порядка сортировки
        cmp si, cx          ; [34] Сравнение для сортировки по убыванию
    %else
        cmp cx, si          ; [35] Сравнение для сортировки по возрастанию
    %endif

    jg swap             ; [36] Если условие выполнено, обменять элементы
    jle not_swap        ; [37] Иначе продолжить без изменений

swap:
    ; Обмен элементов ---------------------------------------------------------
    mov r9b, 0          ; [38] Сброс счетчика столбцов (рестарт фазы)
    mov [matrix+rax+rbx+2], si ; [39] Сохраняем SI в соседнюю ячейку
    mov [matrix+rax+rbx], cx   ; [40] Сохраняем CX в текущую ячейку
    jmp colloop_odd     ; [41] Рестарт нечетной фазы

not_swap:
    ; Продолжение сортировки --------------------------------------------------
    cmp r14, 1          ; [42] Проверка текущей фазы
    je colloop_odd      ; [43] Если нечетная фаза, продолжить её
    jmp colloop_even    ; [44] Иначе продолжить четную фазу

_end:
    ; Завершение программы ----------------------------------------------------
    mov eax, 60         ; [45] Системный вызов exit (60)
    mov edi, 0          ; [46] Код возврата 0 (успех)
    syscall             ; [47] Вызов ядра

Ключевые особенности реализации

    Адресная арифметика:

        Формула доступа к элементу: matrix + (row * cols * 2) + (col * 2)

        Пример для matrix[1][2]: base + (1*5*2) + (2*2) = base + 14

    Управление фазами:

        Регистр R14 хранит флаг фазы (0/1)

        После каждого обмена сброс счетчика (mov r9b, 0) гарантирует повторную проверку всех элементов

    Оптимизации:

        Использование 8-битных частей регистров (r8b, r9b) для счетчиков

        movzx/movsx для корректного расширения байтовых значений

    Условная компиляция:

        Сборка с флагом -dSORT_DESCENDING меняет порядок сравнения:
    bash
    Copy

    nasm -f elf64 -dSORT_DESCENDING program.asm

Визуализация работы

    Нечетная фаза (элементы 0-1, 2-3):

Copy

Исходная строка: [12, -5, 7, 3, 0]
Сравнение пар:
  (12 ↔ -5) → обмен → [-5, 12, 7, 3, 0]
  (7 ↔ 3) → обмен → [-5, 12, 3, 7, 0]

    Четная фаза (элементы 1-2, 3-4):

Copy

После нечетной фазы: [-5, 12, 3, 7, 0]
Сравнение пар:
  (12 ↔ 3) → обмен → [-5, 3, 12, 7, 0]
  (7 ↔ 0) → обмен → [-5, 3, 12, 0, 7]

Процесс повторяется до полной сортировки строки. Алгоритм гарантирует сортировку за O(n^2) операций в худшем случае.